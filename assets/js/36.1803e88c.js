(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{486:function(a,t,e){"use strict";e.r(t);var r=e(1),s=Object(r.a)({},(function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("blockquote",[e("p",[a._v("前端面试题")])]),a._v(" "),e("h2",{attrs:{id:"_1、前端csp是什么？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1、前端csp是什么？"}},[a._v("#")]),a._v(" 1、前端CSP是什么？")]),a._v(" "),e("p",[a._v("CSP(Content Secruity Policy) 的实质就是白名单制度，开发者明确告诉客户端，哪些外部资源可以加载和执行，等同于提供白名单。")]),a._v(" "),e("ul",[e("li",[a._v("被设计为一个完整的框架来防御 XSS 和 CSRF 攻击")]),a._v(" "),e("li",[a._v("通常也可以用来控制 app 和扩展的权限")])]),a._v(" "),e("p",[a._v("CSP 让开发者提高了对 XSS 攻击的防御能力, 但也存在一些问题.")]),a._v(" "),e("ul",[e("li",[a._v("难部署(如要改动左右inline scripts)")]),a._v(" "),e("li",[a._v("对 Origin 的定义不够细致")]),a._v(" "),e("li",[a._v("Binary 安全")])]),a._v(" "),e("h2",{attrs:{id:"_2、手动写一个动画，最小的间隔时间是多久，为什么？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2、手动写一个动画，最小的间隔时间是多久，为什么？"}},[a._v("#")]),a._v(" 2、手动写一个动画，最小的间隔时间是多久，为什么？")]),a._v(" "),e("p",[e("strong",[a._v("1/60*1000ms = 16.7m")])]),a._v(" "),e("p",[a._v("多数显示器的默认频率是60HZ，即每秒刷新60次。所以理论上的最小间隔是 1/60*1000ms = 16.7ms")]),a._v(" "),e("h2",{attrs:{id:"_3、vue中v-for和v-if为什么不能放在同一个标签上"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3、vue中v-for和v-if为什么不能放在同一个标签上"}},[a._v("#")]),a._v(" 3、vue中v-for和v-if为什么不能放在同一个标签上")]),a._v(" "),e("p",[a._v("v-for比v-if优先级高，如果每一次都需要遍历整个数组，将会影响速度，尤其是当之需要渲染很小一部分的时候。")]),a._v(" "),e("p",[a._v("如果连用的话会把 v-if 给每个元素都添加一下,会造成性能问题。")]),a._v(" "),e("h2",{attrs:{id:"_4、什么是节流，什么是防抖，什么是重绘，什么是重排"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4、什么是节流，什么是防抖，什么是重绘，什么是重排"}},[a._v("#")]),a._v(" 4、什么是节流，什么是防抖，什么是重绘，什么是重排?")]),a._v(" "),e("ul",[e("li",[e("p",[a._v("节流(throttle)：连续事件触发，在指定的时间内，不管触发几次，就只执行一次")])]),a._v(" "),e("li",[e("p",[a._v("防抖(debounce)：在事件触发n秒后再执行，如果在n秒内又有新的触发，就重新计算")])]),a._v(" "),e("li",[e("p",[a._v("重绘(Repaint)：是在一个元素的外观被改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。比如改变某个元素的背景色、文字颜色、边框颜色等等")])]),a._v(" "),e("li",[e("p",[a._v("重排(Reflow)：当渲染树的一部分必须更新并且节点的尺寸发生了变化，浏览器会使渲染树中受到影响的部分失效，并重新构造渲染树")])])]),a._v(" "),e("h2",{attrs:{id:"_5、vue中的data为什么是个函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5、vue中的data为什么是个函数"}},[a._v("#")]),a._v(" 5、vue中的data为什么是个函数")]),a._v(" "),e("p",[a._v("因为当 data 是函数时，组件实例化的时候这个函数将会被调用，返回一个对象，计算机会给这个对象分配一个内存地址，实例化几次就分配几个内存地址，他们的地址都不一样，所以每个组件中的数据不会相互干扰，改变其中一个组件的状态，其它组件不变")]),a._v(" "),e("p",[a._v("简单来说，就是为了保证组件的独立性和可复用性，如果 data 是个函数的话，每复用一次组件就会返回新的 data，类似于给每个组件实例创建一个私有的数据空间，保护各自的数据互不影响")]),a._v(" "),e("h2",{attrs:{id:"_6、-route和-router的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6、-route和-router的区别"}},[a._v("#")]),a._v(" 6、$route和$router的区别")]),a._v(" "),e("p",[a._v("$route是一个跳转的路由对象，每一个路由都会有一个route对象，是一个局部的对象，可以获取对应的name,path,params,query等")]),a._v(" "),e("p",[a._v("$router: 是 VueRouter的一个对象，通过Vue.use(VueRouter)和VueRouter构造函数得到一个router的实例对象，是一个全局对象，他包含了所有的路由包含了许多关键的对象和属性；")]),a._v(" "),e("pre",[e("code",[a._v("常用例子：\n")])]),a._v(" "),e("p",[a._v("$router操作 路由跳转")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("this.$router.push({ name:'hello', params:{ name:'张三', age:'18' }})\n")])])]),e("p",[a._v("$route读取 路由参数接收")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("var name = this.$route.params.name;\n")])])]),e("h2",{attrs:{id:"_7、什么是闭包，写一个简单的闭包"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_7、什么是闭包，写一个简单的闭包"}},[a._v("#")]),a._v(" 7、什么是闭包，写一个简单的闭包")]),a._v(" "),e("p",[a._v("闭包就是指有权访问另一个函数作用域中的变量的函数")]),a._v(" "),e("p",[a._v("可以读取函数内部的变量")]),a._v(" "),e("p",[a._v("函数内部的变量保留在内存中，不被销毁")]),a._v(" "),e("p",[a._v("缺点：在闭包不使用的情况下要及时释放，否则将造成内存泄漏")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("function foo() {\n    var num = 1;\n    function bar() {\n        num++;\n        return num;\n    }\n    return bar;\n}\n\nvar func = foo();\nconsole.log(func()); // 2\n")])])]),e("h2",{attrs:{id:"_8、js怎么实现一个类"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_8、js怎么实现一个类"}},[a._v("#")]),a._v(" 8、js怎么实现一个类")]),a._v(" "),e("p",[a._v("js并不是一种面向对向的语言, 没有提供对类的支持, 因此我们不能像在传统的语言里那样 用class来定义类")]),a._v(" "),e("p",[a._v("可以利用js的闭包封装机制来实现js类")]),a._v(" "),e("p",[a._v("构造函数法")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("function Person(name,age) { \n    this.name = name;\n    this.age = age;\n}\nPerson.prototype.outer = function () { \n    return `${name}今年${age}岁`\n}\nvar person = new Person('zhangsan',32);\nperson.outer()\n")])])]),e("p",[a._v("ES6语法糖")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("class Person{\n    constructor(name,age){\n         this.name = name;\n        this.age = age;\n    }\n    outer(){\n        return `${name}今年${age}岁`\n    }\n}\nvar person = new Person('zhangsan',32)\n")])])])])}),[],!1,null,null,null);t.default=s.exports}}]);